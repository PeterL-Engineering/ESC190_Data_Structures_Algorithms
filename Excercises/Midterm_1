// Lab 3

void print_student(student1 *student) {
    printf("Name: %s\n", student->name);
    printf("Student Number: %ld\n", student->student_number);
    printf("Year: %d\n", student->year);
}

void set_default_name(student1 *p_s){
    strcpy(p_s->name, "Default Student");
    p_s->year = 0;
}

void set_default_name_wrong(student1 s){
    strcpy(s.name, "Deafult Student");
    s.year = 0;
}

void create_block1(student1 **p_p_s, int n_students){
    *p_p_s = (student1*)malloc(n_students * sizeof(student1));
}

void set_name(student1 *p_s, const char* name){
    strcpy(p_s->name, name, strlen(p_s->name) - 1);
    p_s->name[-1] = "\0";
}

void destroy_block1(student1 *p_s){
    free(p_s);
}

typedef struct student2{
    char *name;
    char *student_number;
    int year;
} student2;

void create_block2(student2 **p_p_s, int num_students){
    *p_p_s = (student2*)malloc(num_students * sizeof(student2));

    int i = 0;
    for(i; i<= num_students; i++){
        *p_p_s->name = NULL;
        *p_p_s->student_number = NULL;
    }
}

void set_name2(student2 **p_p_s, const char *name){
    *p_p_s->name = (const char*)realloc(p_s.name, strlen(name) + 1);
    strcpy(**p_p_s->name, name)
}

// 2023 Midterm

// Q. 1

typedef struct node {
    int data;
    struct node *next;
} node;

typedef struct LL {
    node *head;
    int size;
} LL;

void LL_append(LL *my_list, int new_elem) {
    // Increase size of LL + 1
    // Malloc space for new elem

    node *new_node = (node*)malloc(sizeof(node));
    new_node->data = new_elem;
    new_node->next = NULL;

    if (my_list->head == NULL) {
        my_list->head = new_node;
    }
    else {
        node *current_node = my_list->head;
        while (current_node->next != NULL) {
            current_node = current_node->next;
        }

        current_node->next = new_node;

    }
    my_list->size++;
}


// Q. 2

char * strcat_rec(char *dest, const char *src) {
    // Base Case
    if (*dest != '\0') {
        strcat_rec(dest + 1, src);
    }
    *dest = *src;
    if (*src == '\0') {
        return dest;
    }
    *(dest + 1) = '\0';
    strcat_rec(dest + 1, src + 1);
    return dest
}

// Q. 3

typedef struct bustiness {
    int phone_number[10]; // Will need atoi later
    char *name;
} business;

void get_line(char **dest, const char *filename, int index) {
    int cur_len = 1;
    *dest = NULL;

    do {
        FILE *fp = fopen(filename, "r");
        *dest - (char*)realloc(*dest, sizeof(char) * cur_len);
        fgets(*dest, cur_len, fp);
        cur_len *= 2;
        fclose(fp);
    } while((*dest)[strlen(*dest) - 1] != '\n');
}

void read_numbers(const char *filename, business **whitepages, int *size) {
    FILE *fp = fopen(filename, "r");
    if (*fp == NULL) {
        printf("ERROR: Could not open file.");
        exit(1);
    }

    *whitepages = (business*)malloc(sizeof(business) * (*size));
    int i = 0;
    for (i; i < *size; i++) {
        char *line = NULL;
        int ph_sz = 0;
        int index = 0;
        get_line(&line, filename, i + 1);
        do {
            if (line[index] != '-') {
                (*whitepages)[i].phone_number[ph_sz++] = line[index];
            }
        } while (line[++index] != '\t');
        index++;
        strcpy(whitepages[i]->name, line + index); // Adress of the start of the line 
        free(line);                                // Plus the phone number and tab
    }

}